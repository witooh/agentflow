name: PR Review (ChatGPT/Codex)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: pr-review-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  review:
    if: github.event.pull_request.draft == false || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate AI Review
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4o-mini' }}
          MAX_PATCH_CHARS: "120000"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            async function main() {
              const apiKey = process.env.OPENAI_API_KEY;
              if (!apiKey) {
                const body = 'AI review is blocked: missing OPENAI_API_KEY secret. Add it in repo Settings â†’ Secrets and rerun.';
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body
                });
                core.info('Missing OPENAI_API_KEY; posted guidance comment.');
                return;
              }

              const { owner, repo } = context.repo;
              const pr_number = context.payload.pull_request.number;

              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: pr_number });

              const files = await github.paginate(
                github.rest.pulls.listFiles,
                { owner, repo, pull_number: pr_number, per_page: 100 }
              );

              let budget = parseInt(process.env.MAX_PATCH_CHARS || '120000', 10);
              const parts = [];
              for (const f of files) {
                const patch = f.patch || '';
                const header = `\n=== FILE: ${f.filename} (${f.status}${f.additions!=null?`, +${f.additions}`:''}${f.deletions!=null?`, -${f.deletions}`:''}) ===\n`;
                const chunk = header + (patch ? patch : '[binary or no diff shown]');
                if (chunk.length <= budget) {
                  parts.push(chunk);
                  budget -= chunk.length;
                } else if (budget > header.length + 200) {
                  parts.push(header + (patch ? patch.slice(0, budget - header.length - 200) : '') + '\n...[truncated]...');
                  budget = 0;
                }
                if (budget <= 0) break;
              }

              const diffBundle = parts.join('\n');

              const system = [
                'You are the Reviewer (Tech Lead) for an AI Software House.',
                'Evaluate pull requests for correctness, style, security, and maintainability.',
                'Project conventions: TypeScript-first, Next.js/TS on FE/BE, Supabase-first, and multi-agent specs in AGENTS.md.',
                'Output concise, actionable feedback.'
              ].join(' ');

              const instructions = [
                `PR: #${pr_number} ${pr.title}`,
                `Author: ${pr.user?.login}`,
                `Base: ${pr.base?.label}  Head: ${pr.head?.label}`,
                `Description: ${pr.body || '(no description)'}`,
                '',
                'Review focus:',
                '- Correctness: logic, edge cases, error handling',
                '- Security: secrets, injection, PII/PDPA adherence',
                '- Style: consistency with repo, clarity, dead code',
                '- DX: tests, docs, run instructions',
                '- Supabase/Env: env vars, RLS, secrets policy (no secrets in code)',
                '',
                'Output format (Markdown):',
                '## Summary',
                '## Blockers',
                '## Findings',
                '## Suggestions',
                '## Release Notes (proposed)',
                '',
                'Be specific. Reference files and lines when clear (e.g., path:line). Keep to ~400-800 words.'
              ].join('\n');

              const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';

              core.info(`Using model: ${model}`);
              const payload = {
                model,
                temperature: 0.2,
                messages: [
                  { role: 'system', content: system },
                  { role: 'user', content: instructions },
                  { role: 'user', content: 'Diff (unified patches):\n' + diffBundle }
                ]
              };

              const resp = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${apiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
              });

              if (!resp.ok) {
                const text = await resp.text();
                core.warning(`OpenAI API error: ${resp.status} ${text}`);
                const body = `AI review failed with API error ${resp.status}. Please check logs.`;
                await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
                return;
              }

              const data = await resp.json();
              const content = data.choices?.[0]?.message?.content?.trim();
              if (!content) {
                core.warning('No content returned from model');
                return;
              }

              await github.rest.pulls.createReview({
                owner, repo, pull_number: pr_number,
                event: 'COMMENT',
                body: content
              });

              core.info('Posted AI review.');
            }

            await main();
